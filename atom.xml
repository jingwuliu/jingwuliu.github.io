<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe Liu的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-05T07:18:00.349Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Joe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>code compile</title>
    <link href="http://example.com/2021/07/05/code-compile/"/>
    <id>http://example.com/2021/07/05/code-compile/</id>
    <published>2021-07-05T06:01:26.000Z</published>
    <updated>2021-07-05T07:18:00.349Z</updated>
    
    <content type="html"><![CDATA[<p>在版本发出前会有编译的步骤，但是对于编译的具体flow没有明确的概念，只知道是将开发源码转换成机器可读的二进制代码的过程，今天我们来具体了解一下。</p><p>简单来说，编译器的作用就是将源文件转换为计算机能直接运行的可执行文件，该可执行文件由一条条的执行指令构成。具体来说，编译源文件需要经过 <font color="#FF0000">预处理</font>、<font color="#FF0000">编译</font> 、<font color="#FF0000">汇编</font>、 <font color="#FF0000">链接</font>四个步骤。我们就以hello world程序为例对4步进行介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;); &#x2F;&#x2F;输出hello world</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.c文件(源文件)</span><br></pre></td></tr></table></figure><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理是从我们编写的源代码到机器可读文件的第一步，上述源码中第一行的”#”号代表这是一条预处理指令，第一行引入了标准输入输出库，我们称之为头文件，或是库。其次预处理的过程帮助我们删除了多余的注释，如第四行的”//输出hello world”。预处理后的文件会将源码开头中引入的库/头文件内容加入到代码中。并删除注释部分，如下图所示。图中可以看到前面的795行都是stdio.h的代码。</p><p><img src="/2021/07/05/code-compile/premake1.png" alt="预处理后的文件a"></p><p><img src="/2021/07/05/code-compile/premake2.png#pic_center" alt="预处理后的文件b"></p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译过程会将预处理后的文件转换为汇编语言表述的文件，汇编语言就是为了简化繁琐的机器语言编程所创造的一系列助记符。汇编语言和机器指令是一一对应的，如果更换cpu，那就要采用对应的汇编语言。<br>编译阶段首先进行词法分析和语法分析，检查代码的规范性、是否有语法错误等。接下来对代码进行优化，最后生成汇编代码。</p><p><img src="/2021/07/05/code-compile/compile.png#pic_center" alt="编译后产生的汇编代码"></p><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编过程就是基于上述与汇编代码对应的机器指令集将汇编代码进行替换的过程，这个过程将汇编代码转换为二进制的目标代码。但目前还不是一个完整的可执行文件，无法运行。还需要最后一步。</p><p><img src="/2021/07/05/code-compile/compile1.png" alt="汇编后产生的二进制目标文件"></p><p><img src="/2021/07/05/code-compile/compile2.png" alt="16进制显示的二进制目标文件"></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>经过汇编后生成的二进制目标文件还不是一个完整的可执行文件，仍然缺少库函数，几乎所有的程序中都要使用各类的标准库中的函数，如C语言中的printf()函数，最上面的源码中只包含了对printf()函数的声明，该函数真正的代码(预编译号的二进制文件)存储在其它地方。<br>除此外，目标文件还缺少启动代码，启动代码充当着程序和操作系统间的接口，不同操作系统所需要的启动代码不同。<br>所以在链接步骤中，我们需要先将源码中使用到的声明的标准库函数的目标代码，启动代码都合入到汇编产生的二进制目标文件中，生成最终版的二进制可执行文件。</p><p><img src="/2021/07/05/code-compile/final_file.png" alt="可执行二进制目标文件"></p><h4 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a><font color="#FF0000">汇编</font></h4><p><img src="/2021/07/05/code-compile/conclude.png" alt="编译流程图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在版本发出前会有编译的步骤，但是对于编译的具体flow没有明确的概念，只知道是将开发源码转换成机器可读的二进制代码的过程，今天我们来具体了解一下。&lt;/p&gt;
&lt;p&gt;简单来说，编译器的作用就是将源文件转换为计算机能直接运行的可执行文件，该可执行文件由一条条的执行指令构成。具体来</summary>
      
    
    
    
    
    <category term="编译" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>vue basic</title>
    <link href="http://example.com/2021/04/12/vue-basic/"/>
    <id>http://example.com/2021/04/12/vue-basic/</id>
    <published>2021-04-12T06:41:53.000Z</published>
    <updated>2021-05-13T09:11:46.065Z</updated>
    
    <content type="html"><![CDATA[<p>slot，也就是插槽，是Vue组件的一块HTML模板，该模板是否显示、如何显示由其父组件决定。插槽是一块模板，从模板种类角度来分，可以分为非插槽模板和插槽模板两类。</p><ul><li>非插槽模板是html模板，像div、span、ul、table这些，它们的显示与否以及显示效果是由组件自身控制。</li><li>插槽模板是slot，它是一个空壳子，插槽显示的位置由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板就会显示在什么位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">        &lt;h3&gt;父组件&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;child&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;temp1&gt;</span><br><span class="line">                &lt;span&gt;menu1&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;span&gt;menu2&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">        &lt;h3&gt;子组件&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在这里，子组件的插槽被父组件下的html模板使用了。所以子组件会变成这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;temp1&gt;</span><br><span class="line">    &lt;span&gt;menu1&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span&gt;menu2&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>匿名插槽没有name属性，插槽加了name属性就变成了具名插槽。它可以在一个组件中出现N次，出现在不同的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;这里是父组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;tmpl&quot; slot&#x3D;&quot;up&quot;&gt;</span><br><span class="line">        &lt;span&gt;菜单1&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单2&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单3&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单4&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单5&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单6&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;tmpl&quot; slot&#x3D;&quot;down&quot;&gt;</span><br><span class="line">        &lt;span&gt;菜单-1&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-2&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-3&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-4&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-5&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-6&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;tmpl&quot;&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;1&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;2&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;3&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;4&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;5&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;菜单-&gt;6&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 具名插槽</span><br><span class="line">    &lt;slot name&#x3D;&quot;up&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &#x2F;&#x2F; 具名插槽</span><br><span class="line">    &lt;slot name&#x3D;&quot;down&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &#x2F;&#x2F; 匿名插槽</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="作用域插槽-数据插槽"><a href="#作用域插槽-数据插槽" class="headerlink" title="作用域插槽/数据插槽"></a>作用域插槽/数据插槽</h2><p>这样的插槽往往带有动态的数据，需要在slot上绑定数据，<br>父组件提供了样式，但没有提供数据，数据使用的子组件插槽自己绑定的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">        &lt;h3&gt;父组件&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;child&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;user&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;temp1&quot;&gt;</span><br><span class="line">                    &lt;span v-for&#x3D;&quot;item in user.data&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;child&gt;</span><br><span class="line"></span><br><span class="line">        &lt;child&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;user&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for&#x3D;&quot;item in user.data&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;child&gt;</span><br><span class="line"></span><br><span class="line">        &lt;child&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;user&quot;&gt;</span><br><span class="line">                &#123;&#123; user.data &#125;&#125;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">        &lt;h3&gt;子组件&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;slot :data&#x3D;&quot;data&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data: function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            data: [&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wanwu&#39;,&#39;zhaoliu&#39;,&#39;tianqi&#39;,&#39;xiaoba&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="table中的插槽"><a href="#table中的插槽" class="headerlink" title="table中的插槽"></a>table中的插槽</h2><p>在使用<a href="https://www.antdv.com/components/table-cn">ant design vue</a>的table的时候，我们经常可以看见<slot>,<slot-scope>等字段，这里其实就用到了插槽。<br><img src="/2021/04/12/vue-basic/table-slot.png" alt="table-slot"><br>slot=”name”表示是在name这一列中插入”查看”和”删除操作，<br>slot-scope=”text record”的话，record表示当前行的数据，可以通过传递record来获取当前行的所有数据。</slot-scope></slot></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;slot，也就是插槽，是Vue组件的一块HTML模板，该模板是否显示、如何显示由其父组件决定。插槽是一块模板，从模板种类角度来分，可以分为非插槽模板和插槽模板两类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非插槽模板是html模板，像div、span、ul、table这些，它们的显示与否</summary>
      
    
    
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch原理介绍</title>
    <link href="http://example.com/2021/03/23/elasticsearch-docs/"/>
    <id>http://example.com/2021/03/23/elasticsearch-docs/</id>
    <published>2021-03-23T09:33:26.000Z</published>
    <updated>2021-04-13T06:58:57.927Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作中项目需要更换database，所以也开始去了解一些elasticsearch的基础知识。</p><p>总的来说，Elasticsearch是一个分布式的存储和搜索引擎，适用于包括文本、数字、结构化和非结构化数据等所有类型的数据，<a href="https://www.elastic.co/cn/">官网速递</a>。<br>首先我们要了解一种索引方式，叫倒排索引。顾名思义，和我们平时生活中常用的索引方式不太一样。就拿背古诗来举例，对于普通的索引方式，往往是以(key-诗名 value-诗文)的方式进行存储和索引的。<br><img src="/2021/03/23/elasticsearch-docs/key-value.png" alt="常规key-value示意图"><br>但是当我们想要通过关键词去寻找相关诗句时，如寻找带有”前”的诗句，由于缺少相关的索引，所以我们只能遍历记忆中的所有诗词，难以在短时间内得到结果，这时就需要我们的倒排索引了。倒排索引又叫反向索引。倒排索引往往会以类似于诗句中的每个字作为索引的key，而诗句内容作为value。即如下方法。<br><img src="/2021/03/23/elasticsearch-docs/new-key-value.png" alt="倒排索引key-value示意图"><br>针对这样的一句诗句，我们就会建立10个索引(诗句中10个字)。相比较而言，原来的正向索引只需要一个索引，而反向需要10个，这样可能会导致我们的存储量爆炸增长。所以我们考虑将数据进行压缩。将key-value的对应更改为(key-关键词 value-诗名)的形式。<br><img src="/2021/03/23/elasticsearch-docs/new-key-value3.jpg" alt="倒排索引key-value新示意图"><br>这样的方式就可以保证减少数据量。相应的，我们也需要形成(key-诗名 value-诗句)的索引矩阵帮助我们寻找。<br><img src="/2021/03/23/elasticsearch-docs/new-key-value4.png" alt="倒排索引key-value新示意图4"><br>可以看到，静夜思和望庐山瀑布中都包含“前”字，而静夜思、月下独酌中都有“月”字，所以我们在对于多首诗建立索引时也可以这样。<br><img src="/2021/03/23/elasticsearch-docs/new-key-value5.png" alt="倒排索引key-value新示意图5"><br>我们日常生活中使用的搜索引擎的原理也是这样的，最核心的都是建立倒排索引。只不过它们的流程稍微复杂一些，还包括网页爬取、停顿词过滤等。停顿词过滤会帮助引擎过滤掉一些诸如“的”、“而”等本身无意义的停顿词，即分词，然后再根据剩余的关键词进行索引。<br>在很早以前，业界有一个叫做<strong>lucene</strong>的库，用来实现倒排索引，后来人们对于lucene进行再次封装，写出了<strong>Elasticsearch</strong>。<br>Elasticsearch将对搜索引擎的操作都封装成了restful的api，通过http请求就可以对其进行操作。想要了解Elasticsearch，我们需要先了解几个专有名词。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>这里说的索引和刚刚说的key索引不是一个概念，elasticsearch中的索引是存放数据的地方，可以理解成mysql中的数据库。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>类型就是用来定义数据结构的，可以认为是mysql中的一张表。</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档可以被认为就是最终的数据了，可以理解成我们每次需要上传的数据都是文档，即一条记录。<br><img src="/2021/03/23/elasticsearch-docs/elasticsearch-mysql.png" alt="elasticsearch-mysql"></p><h4 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><p>比如一首诗，有诗题、作者、朝代、字数、诗内容等，首先我们可以建立一个名为poems的索引，诗题、作者、朝代都是keyword类型，而诗内容是text类型，字数是interger类型，最后把数据组织成json格式存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">index</span><br><span class="line">poems</span><br><span class="line"></span><br><span class="line">type</span><br><span class="line">“poem”: &#123; </span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;author&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dynasty&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;words&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;interger&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;静夜思&quot;,</span><br><span class="line">    &quot;author&quot;: &quot;李白&quot;,</span><br><span class="line">    &quot;dynasty&quot;: &quot;唐&quot;,</span><br><span class="line">    &quot;words&quot;: &quot;20&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;床前明月光，疑是地上霜，举头望明月，低头思故乡。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型相当于表结构的描述，描述每个字段的类型，文档以json形式描述数据。针对上述数据类型，keyword类型是不会分词的，直接根据字符串内容建立反向索引，而text类型存入elasticsearch前会先分词，再根据分词后内容建立倒排索引。而我们只需要给elasticsearch发送http请求就可以成功建立索引。</p><h4 id="Elasticsearch分布式原理"><a href="#Elasticsearch分布式原理" class="headerlink" title="Elasticsearch分布式原理"></a>Elasticsearch分布式原理</h4><p>elasticsearch也会对数据进行切分，同时每一个分片会保存多个副本，从而保证分布式环境下的高可用。<br><img src="/2021/03/23/elasticsearch-docs/elastic-store.png" alt="elastic-store"><br>图中绿色的表示数据块，也可以成为分片(shard)，它保存了索引中所有数据的一部分，即部分数据的容器。文档存放在分片中，分片会被分配到集群的节点上，当集群扩容或缩小，Elasticsearch也会自动在节点间迁移分片，以使集群保持平衡。分片也会被备份生成复制分片存储到多个节点中，每个节点是对等的，节点会通过一些规则选取集群的Master，Master会负责集群状态信息的改变，并同步给其它节点。</p><h4 id="Elasticsearch实战搜索"><a href="#Elasticsearch实战搜索" class="headerlink" title="Elasticsearch实战搜索"></a>Elasticsearch实战搜索</h4><p>假设我们有这样一个集群，我们将数据切分为两块，分别为P0、P1，将P0、P1分别生成两个复制分片并存放于不同的节点上，如图所示。<br><img src="/2021/03/23/elasticsearch-docs/elastic-search.png" alt="elastic-search"><br>假设我们想要去对文档进行索引，索引步骤一般如下：</p><ul><li>客户端给集群中的Master(假设为Node1)发送GET请求。</li><li>节点使用文档提供的_id确定需要被索引的文档包含在分片0中，分片0对应的复制分片在三个节点上都有。此时，它转发请求到Node2。</li><li>Node2返回文档给Node1后将检索结果返回给客户端。</li></ul><h5 id="索引结果字段说明"><a href="#索引结果字段说明" class="headerlink" title="索引结果字段说明"></a>索引结果字段说明</h5><p>最基本的索引就是空搜索，这里不会只当任何的查询条件，这样会返回集群索引中的所有文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br></pre></td></tr></table></figure><p>响应内容往往如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;hits&quot; : &#123;</span><br><span class="line">        &quot;total&quot; :       14,</span><br><span class="line">        &quot;hits&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:   &quot;us&quot;,</span><br><span class="line">            &quot;_type&quot;:    &quot;tweet&quot;,</span><br><span class="line">            &quot;_id&quot;:      &quot;7&quot;,</span><br><span class="line">            &quot;_score&quot;:   1,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">                &quot;date&quot;:    &quot;2014-09-17&quot;,</span><br><span class="line">                &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">                &quot;tweet&quot;:   &quot;The Query DSL is really powerful and flexible&quot;,</span><br><span class="line">                &quot;user_id&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ... 9 RESULTS REMOVED ...</span><br><span class="line">        ],</span><br><span class="line">        &quot;max_score&quot; :   1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;took&quot; :           4,</span><br><span class="line">    &quot;_shards&quot; : &#123;</span><br><span class="line">        &quot;failed&quot; :      0,</span><br><span class="line">        &quot;successful&quot; :  10,</span><br><span class="line">        &quot;total&quot; :       10</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timed_out&quot; :      false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>hits</strong>:hits包含了total字段来表示匹配到的文档总数，hits数组还会包含匹配到的前10条数据。<br>hits数组中的每个结果都包含_index、_type和文档的_id字段，被加入到_source字段中这意味着在搜索结果中我们将可以直接使用全部文档。这不像其他搜索引擎只返回文档ID，需要你单独去获取文档。<br>每个节点都有一个_score字段作为相关性得分，它衡量了文档与索引的匹配程度。默认的，返回的结果中关联性最大的文档排在首位；由于我们没有指定任何查询，所有文档的相关性是一样的，因此所有的_score都是取得中间值1。<br>max_score指的是所有文档匹配查询中_score的最大值。</p></li><li><p><strong>took</strong>:索引请求花费的毫秒数。</p></li><li><p><strong>shards</strong>:参与索引的分片数量，有多少是成功和失败的。</p></li><li><p><strong>timeout</strong>:返回查询超时与否。timeout不会停止执行索引，仅会告诉在指定timeout内顺利返回结果的节点然后关闭连接。在后台依然可以执行查询。</p></li></ul><h4 id="搜索引擎原理总结"><a href="#搜索引擎原理总结" class="headerlink" title="搜索引擎原理总结"></a>搜索引擎原理总结</h4><ul><li>反向索引又叫倒排索引，是根据文章内容中的关键字建立索引。</li><li>搜索引擎原理就是建立反向索引。</li><li>Elasticsearch 在 Lucene 的基础上进行封装，实现了分布式搜索引擎。</li><li>Elasticsearch 中的索引、类型和文档的概念比较重要，类似于 MySQL 中的数据库、表和行。</li><li>Elasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。</li></ul><p>开发视图用于描述系统的模块划分和组成，以及细化到内部包的组成设计，服务于开发人员，反映系统开发实施过程。</p><p>本文内容参考于<a href="https://zhuanlan.zhihu.com/p/62892586">终于有人把Elasticsearch原理讲透了！</a>, <a href="https://blog.csdn.net/u012834750/article/details/88045861">Elasticsearch系列(六)ES数据搜索之基本流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于工作中项目需要更换database，所以也开始去了解一些elasticsearch的基础知识。&lt;/p&gt;
&lt;p&gt;总的来说，Elasticsearch是一个分布式的存储和搜索引擎，适用于包括文本、数字、结构化和非结构化数据等所有类型的数据，&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
    <category term="倒排索引" scheme="http://example.com/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Verdaccio介绍</title>
    <link href="http://example.com/2021/02/24/Verdaccio%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/02/24/Verdaccio%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-02-24T02:19:42.000Z</published>
    <updated>2021-02-24T02:27:09.429Z</updated>
    
    <content type="html"><![CDATA[<p>Verdaccio是一个轻量级、零配置本地私有npm软件包代理注册表。Verdaccio拥有自己的npm私有部署小型数据库，能够代理其它注册表，缓存下载的模块。此外Verdaccio易于扩展存储功能，支持各种社区制作的插件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Verdaccio是一个轻量级、零配置本地私有npm软件包代理注册表。Verdaccio拥有自己的npm私有部署小型数据库，能够代理其它注册表，缓存下载的模块。此外Verdaccio易于扩展存储功能，支持各种社区制作的插件。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Verdaccio" scheme="http://example.com/tags/Verdaccio/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose.yml的基础使用</title>
    <link href="http://example.com/2021/02/07/docker-compose/"/>
    <id>http://example.com/2021/02/07/docker-compose/</id>
    <published>2021-02-07T09:20:58.000Z</published>
    <updated>2021-03-16T06:53:01.582Z</updated>
    
    <content type="html"><![CDATA[<p>docker-compose.yml文件用来做项目编排，负责实现对Docker容器集群的快速编排，部署分布式应用，通过一个单独的yaml文件为一个项目来定义一组相关联的应用容器。文件中主要包含了使用各种镜像创建的容器服务，使用的镜像可以是网络上的，也可以是根据Dockerfile文件生成的。</p><p>一份标准docker-compose.yml配置文件应包含<strong>version</strong>、<strong>service</strong>、<strong>networks</strong>三部分，其中最关键的就是<em>service</em>和<em>networks</em>两部分。</p><ul><li>services标签下的第二级标签的名字由用户自定义，其就为服务名称。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    vue-client:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>services下的服务里仍然有需要方法可以执行，下面我们将选择部分进行介绍。</p><h2 id="image">image</h2><pre><code>image可以直接指定服务的镜像名称或ID。如果镜像在本地不存在，compose将会尝试拉取这个镜像。格式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services: </span><br><span class="line">    vue-client: </span><br><span class="line">        image: hello-world </span><br><span class="line">        &#x2F;&#x2F;&#x2F;image: ubuntu:16.04 </span><br><span class="line">        &#x2F;&#x2F;&#x2F;image: a4bc65fd   </span><br></pre></td></tr></table></figure></code></pre><h2 id="build">build</h2><pre><code>服务也可以使用build基于一份Dockerfile，在使用docker-compose up启动时执行构建任务。Compose会利用提供的路径自动构建该镜像，然后使用这个镜像启动服务容器。如果你同时指定了image和build两个标签，那么Compose会构建镜像并且把镜像命名为image提供的名称。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services: </span><br><span class="line">    vue-client:</span><br><span class="line">        build: .&#x2F;build&#x2F;client</span><br></pre></td></tr></table></figure><h2 id="command">command</h2><pre><code>使用command可以覆盖容器启动后默认执行的命令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    vue-client:</span><br><span class="line">        command: [&quot;--replSet&quot;, &quot;rs0&quot;, &quot;--bind_ip_all&quot;]</span><br><span class="line">        &#x2F;&#x2F;&#x2F;command: --replSet rs0 --bind_ip_all</span><br></pre></td></tr></table></figure></code></pre><h2 id="container-name">container_name</h2><pre><code>该指令用于指定生成的容器的标签名。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    vue-client:</span><br><span class="line">        container_name: vue-client</span><br></pre></td></tr></table></figure></code></pre><h2 id="env-file">env_file</h2><pre><code>在docker-compose.yml中可以定义一个专门存放变量的文件。也可以通过docker-compose -f FILE的方式指定docker-compose.yml配置文件，相应的配置文件中的env_file也会使用配置文件路径。- docker-compose.yml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    vue-client:</span><br><span class="line">        env_file: .env</span><br></pre></td></tr></table></figure>- .env<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MONGODB_DB_NAME&#x3D;release-test</span><br><span class="line">MEDA_DATA_PATH&#x3D;&#x2F;meda_data&#x2F;release_test&#x2F;images&#x2F;</span><br><span class="line">CLIENT_PORT&#x3D;3001:80</span><br></pre></td></tr></table></figure></code></pre><h2 id="environment">environment</h2><pre><code>添加环境变量，可以使用数组或字典。作用就是为镜像设置变量，将变量保存到镜像中，由此镜像生成的容器同样也会包含这些变量设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    node-server:</span><br><span class="line">        environment:</span><br><span class="line">            MONGODB_URL: &quot;mongodb:&#x2F;&#x2F;mongo1:27017&quot;</span><br><span class="line">            MONGODB_DB_NAME: &quot;release-test-1&quot;</span><br></pre></td></tr></table></figure></code></pre><h2 id="healthcheck">healthcheck</h2><pre><code>用于检查测试服务使用的容器是否正常。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    mongo:</span><br><span class="line">       healthcheck:</span><br><span class="line">            test: [&quot;CMD&quot;,&quot;curl&quot;,&quot;-f&quot;,&quot;http:&#x2F;&#x2F;localhost&quot;]</span><br><span class="line">            interval: 15s</span><br><span class="line">            timeout: 10s</span><br><span class="line">            retries: 3</span><br><span class="line">            start_period: 10s</span><br></pre></td></tr></table></figure>其中interval、timeout、start_period都定位持续时间。test中的内容必须是字符串或列表。</code></pre><h2 id="ports">ports</h2><pre><code>映射端口。可以使用HOST:CONTAINER的方式指定端口，可以指定容器和主机端口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">    file-server:</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;9950:80&quot;</span><br><span class="line">            - &quot;8090:8090&quot;</span><br></pre></td></tr></table></figure></code></pre><h2 id="volumes">volumes</h2><pre><code>挂载一个目录或已存在的数据卷容器，直接使用HOST:CONTAINER的格式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- services:</span><br><span class="line">    engine-center:</span><br><span class="line">        volumes:</span><br><span class="line">            - &quot;&#x2F;meda_data&#x2F;release_test&#x2F;images:&#x2F;app&#x2F;meda_output&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">    mongo:</span><br><span class="line">        volumes:</span><br><span class="line">            - &quot;dbdata1:&#x2F;data&#x2F;db&quot;</span><br><span class="line"></span><br><span class="line">- volumes:</span><br><span class="line">    dbdata1:</span><br></pre></td></tr></table></figure></code></pre><h1>docker compose常用命令</h1><h2 id="dockers-compose-f-docker-compose-yml-up-d">dockers-compose (-f) docker-compose.yml up -d</h2><pre><code>在后台启动服务。</code></pre><h2 id="docker-compose-ps">docker-compose ps</h2><pre><code>查看启动的服务。</code></pre><h2 id="docker-compose-stop">docker-compose stop</h2><pre><code>停止目前处于运行状态的容器，但不删除。</code></pre><h2 id="docker-compose-down">docker-compose down</h2><pre><code>停用移除所有容器以及相关网络。</code></pre><h2 id="docker-compose-start">docker-compose start</h2><pre><code>启动已经存在的服务容器。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;docker-compose.yml文件用来做项目编排，负责实现对Docker容器集群的快速编排，部署分布式应用，通过一个单独的yaml文件为一个项目来定义一组相关联的应用容器。文件中主要包含了使用各种镜像创建的容器服务，使用的镜像可以是网络上的，也可以是根据Dockerf</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Docker-compose" scheme="http://example.com/tags/Docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins集成钉钉机器人实现在钉钉上发送任务信息</title>
    <link href="http://example.com/2021/01/28/Jenkins-DingTalkPlugin/"/>
    <id>http://example.com/2021/01/28/Jenkins-DingTalkPlugin/</id>
    <published>2021-01-28T07:20:25.000Z</published>
    <updated>2021-02-20T06:33:52.513Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作需求，考虑使用钉钉机器人代替邮件的功能发送任务信息，所以自己也是摸索了一番。首先钉钉机器人自然是需要依托于钉钉应用的，且钉钉机器人只能在群组里以群主的身份进行创建。</p><h2 id="创建钉钉机器人"><a href="#创建钉钉机器人" class="headerlink" title="创建钉钉机器人"></a>创建钉钉机器人</h2><p>在桌面钉钉上，点击左上角的头像后，点击机器人管理，选择添加自定义机器人(通过Webhook接入自定义服务)。</p><p><img src="/2021/01/28/Jenkins-DingTalkPlugin/create1.png"> &emsp; &emsp;<img src="/2021/01/28/Jenkins-DingTalkPlugin/create2.png"></p><p>接下来需要设置机器人名字，并选择添加到的群组。机器人会自动生成Webhook地址，这个我们后续会在Jenkins上使用。安全设置过程目前支持三种方式，分别是自定义关键词、加签、IP地址(段)。分别是填入自定义关键词、生成密钥、填入IP地址，并在Jenkins上进行映射的关系进行安全的保障。</p><p><img src="/2021/01/28/Jenkins-DingTalkPlugin/create3.png"></p><p>创建完成后，在群里里就可以看到可爱的钉钉机器人的消息啦。</p><p><img src="/2021/01/28/Jenkins-DingTalkPlugin/create4.png"></p><h2 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h2><ul><li>钉钉插件安装。想要在Jenkins上使用钉钉机器人的功能，首先必须要安装钉钉插件。需要依次在Jenkins的首页点击<strong>Manage Jenkins—&gt;Manage Plugins—&gt;Available</strong>，搜索<em>DingTalk</em>，并进行安装，目前我是用的版本是2.4.3，我们也可以看到插件的<a href="https://jenkinsci.github.io/dingtalk-plugin/">中文文档</a>。</li></ul><p><img src="/2021/01/28/Jenkins-DingTalkPlugin/config1.png"></p><ul><li>安装完成后，我们可以回到首页点击<strong>Manage Jenkins—&gt;Configure System</strong>下找到钉钉，填写机器人的名称，Webhook，关键字/加密的信息(上述部分信息可在生成机器人处查看)，并点击测试。显示测试成功的话,并在钉钉群组内可以看到反馈信息，就说明Jenkins和钉钉机器人间的桥梁就搭建成功啦！</li></ul><p><img src="/2021/01/28/Jenkins-DingTalkPlugin/config2.png">  &emsp;  <img src="/2021/01/28/Jenkins-DingTalkPlugin/config3.png"></p><ul><li>具体的针对钉钉机器人反馈的信息也可以进行自定义的设置。其中对于Freestyle Project和Pipeline都有不同的设置方法。具体也可见<a href="https://jenkinsci.github.io/dingtalk-plugin/guide/getting-started.html">钉钉机器人插件中文文档</a>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于工作需求，考虑使用钉钉机器人代替邮件的功能发送任务信息，所以自己也是摸索了一番。首先钉钉机器人自然是需要依托于钉钉应用的，且钉钉机器人只能在群组里以群主的身份进行创建。&lt;/p&gt;
&lt;h2 id=&quot;创建钉钉机器人&quot;&gt;&lt;a href=&quot;#创建钉钉机器人&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="DingTalk" scheme="http://example.com/tags/DingTalk/"/>
    
  </entry>
  
  <entry>
    <title>持续集成之Jenkins插件 Multiple SCMs Plugin搭配使用</title>
    <link href="http://example.com/2021/01/11/jenkins-multiple-SCMs/"/>
    <id>http://example.com/2021/01/11/jenkins-multiple-SCMs/</id>
    <published>2021-01-11T01:45:34.000Z</published>
    <updated>2021-02-20T06:29:33.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目需要，我们的代码被分为了多个版本库进行管理，但我们希望使用一个Job去同时监控多个版本库，最终我们找到了它：<a href="https://plugins.jenkins.io/multiple-scms/">Multiple SCMs Plugin</a>，该插件能实现以下目标：</p><ul><li><p>同时监测多个版本库，其中有一个或多个版本库有新的提交，就能自动触发新的构建。</p></li><li><p>同时监测的多个版本库可以来自不同的代码管理器，实现混搭，如Github，Bitbucket，Mercurial等。</p></li></ul><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>插件可以在Manage Jenkins–Manage Plugins里搜索到并进行下载安装。进入Jenkins Job后选择Multiple SCMs，会出现Add SCMs，我们在下拉框中可以选择想要添加的版本库类型。<br><img src="/2021/01/11/jenkins-multiple-SCMs/source_code_management.png" alt="Source_Code_Management"></p><p>在<strong>Build Triggers</strong>中选择上“Build when a change is pushed to BitBucket”和“Build with BitBucket Push and Pull Request Plugin”，并在对应的位置填入需要监测的版本库位置和分支。在Triggers中同样可以加入多个版本库地址进行行为监控。</p><p><img src="/2021/01/11/jenkins-multiple-SCMs/build_triggers.png" alt="Build_Triggers"></p><p>最后在<strong>Build</strong>中选择Execute Shell加入需要执行的命令行内容，这样完整的监控多个版本库并实时CI的过程就基本完成了。</p><p><img src="/2021/01/11/jenkins-multiple-SCMs/build.png" alt="Build"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于项目需要，我们的代码被分为了多个版本库进行管理，但我们希望使用一个Job去同时监控多个版本库，最终我们找到了它：&lt;a href=&quot;htt</summary>
      
    
    
    
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="Multiple SCMs" scheme="http://example.com/tags/Multiple-SCMs/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins下Join插件介绍</title>
    <link href="http://example.com/2021/01/08/jenkins-join/"/>
    <id>http://example.com/2021/01/08/jenkins-join/</id>
    <published>2021-01-08T09:06:48.000Z</published>
    <updated>2021-02-20T06:30:55.303Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇的内容，我们今天将介绍Jenkins下Join插件的作用。</p><p>Join插件允许在直接下游作业完成后运行作业。这样，执行可以实现并行分支或执行其他步骤，然后在完成所有并行工作后最终聚合。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们的构建由四个作业组成–Test，TestDown1，TestDown2，TestJoin。这些作业都将按照既定的顺序执行。</p><p>我们需要去定义作业之间的顺序关系，在<strong>Post-build Actions</strong>里设置“Build other projects”和“Join Trigger”以设定你的任务的下一级job以及在下一级Job完成后接着要运行的job，内容如图所示。</p><h2 id="基本作业的配置"><a href="#基本作业的配置" class="headerlink" title="基本作业的配置"></a>基本作业的配置</h2><p><img src="/2021/01/08/jenkins-join/jenkins_post_build_actions.png"></p><p>在这个过程中，testDown和testDown2会在初始job完成后并行，并在上述下游任务完成后运行testJoin。我们也可以选择下游Job的执行权限是依据上游任务的成功与否去决定。</p><p><img src="/2021/01/08/jenkins-join/build_other_projects.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接上一篇的内容，我们今天将介绍Jenkins下Join插件的作用。&lt;/p&gt;
&lt;p&gt;Join插件允许在直接下游作业完成后运行作业。这样，执行可以实现并行分支或执行其他步骤，然后在完成所有并行工作后最终聚合。&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; clas</summary>
      
    
    
    
    
    <category term="Jenkins" scheme="http://example.com/tags/Jenkins/"/>
    
    <category term="Join" scheme="http://example.com/tags/Join/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins+Docker+Selenium使用过程中碰到的一些问题</title>
    <link href="http://example.com/2021/01/08/jenkins_problem/"/>
    <id>http://example.com/2021/01/08/jenkins_problem/</id>
    <published>2021-01-08T08:43:50.000Z</published>
    <updated>2021-02-20T06:37:00.261Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作上的需求，需要使用Jenkins去检测每一次的git commit行为，检测到后触发测试代码，重启docker服务并使用Selenium对界面数据进行自动化获取并比对。接下来会分享一些我在工作过程中遇到的问题及解决方案。</p><h2 id="Jenkins构建找不到python相关依赖"><a href="#Jenkins构建找不到python相关依赖" class="headerlink" title="Jenkins构建找不到python相关依赖"></a>Jenkins构建找不到python相关依赖</h2><p>我自己用的是python进行test case编写，但是在jenkins上进行测试时，发现总是提示找不到相应的import，后来发现我们在测试机上装的python相关依赖是在用户下的，而jenkins所在另外一个组，无法调用相关python依赖包，所以出现了相关错误。</p><h2 id="Jenkins无法monitor仓库内submodule下的行为"><a href="#Jenkins无法monitor仓库内submodule下的行为" class="headerlink" title="Jenkins无法monitor仓库内submodule下的行为"></a>Jenkins无法monitor仓库内submodule下的行为</h2><p>工作任务需要监视一个repository及其submodule下的行为并基于git行为触发相应动作。由于是初次使用Jenkins，所以在build Job时选择的是freestyle project，并在Source Code Management下选择的Git，并填入了相应的Repository URL和Credentials，由于任务中存在Submodule，所以也在Add中选择了<strong>Recursively update submodules</strong>和<strong>Use cendentials from default remote of parent repository</strong>，其中前者递归更新子模块会帮助递归检索所有子模块；后者保证子模块可以使用来自父仓库的默认远程凭据。</p><p><img src="/2021/01/08/jenkins_problem/advanced_submodules_behaviours.png" alt="Advanced sub-modules behaviours"><br>为了实现监视仓库行为并自动触发job任务的过程，我们在Build Triggers下选择了<strong>Build with Bitbucket Push and Pull Request Plugin</strong>插件，该插件使得我们的主仓库在有Git行为时Job可以实时的build任务。</p><p><img src="/2021/01/08/jenkins_problem/Build_with_Bitbucket_Push_Pull_Request_Plugin.png" alt="Build with Bitbucket Push and Pull Request Plugin"></p><p>并在Bitbucket上的repository下配置了Webhooks，webhook简单来说就是callback，针对Bitbucket上的行为会触发request并将request传递给相应地址。</p><p><img src="/2021/01/08/jenkins_problem/webhooks.png" alt="Webhooks"></p><p>如图所示，我们可以自由选择Webhooks需要监控的Events</p><p><img src="/2021/01/08/jenkins_problem/webhooks_generation.png"></p><p>但是在实际应用中发现当Submodule上有新的行为时Job无法检测到，所以这里我们考虑建立多个Job，每个Job都会连接相应的Repository且唯一任务就是监控Repository的行为，并在监测到后利用<strong>Post-build Actions</strong>将任务传递到主Job上再run任务。</p><p><img src="/2021/01/08/jenkins_problem/post_build_actions.png"></p><p>对于<strong>Join Plugin</strong>，我们将在后面的小节进行介绍。由于我们共有两个submodule，所以最终的流程类似于下面的图形。<br>这样我们的整个过程就实现啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于工作上的需求，需要使用Jenkins去检测每一次的git commit行为，检测到后触发测试代码，重启docker服务并使用Selenium对界面数据进行自动化获取并比对。接下来会分享一些我在工作过程中遇到的问题及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;Jenkins构建找</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Dockerfile" scheme="http://example.com/tags/Dockerfile/"/>
    
    <category term="Docker-compose" scheme="http://example.com/tags/Docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像、容器和仓库</title>
    <link href="http://example.com/2020/12/30/image-container-relationship/"/>
    <id>http://example.com/2020/12/30/image-container-relationship/</id>
    <published>2020-12-30T13:28:33.000Z</published>
    <updated>2021-02-20T06:23:19.811Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讲解在docker中镜像和容器概念以及两者间的关系。</p><h2 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h2><p>docker的镜像概念类似虚拟机的镜像，可以看作是由多个镜像层叠加起来的文件系统。是一个只读的模板，基于base镜像可以创建新的容器，为指定的镜像添加一个可读写层，构成一个新的容器。</p><p><span><div align="center"><br><img src="/2020/12/30/image-container-relationship/docker_image1.png"></div></span></p><p>根据上图，镜像层的主要组成部分是镜像层ID、镜像层指针(指向父层)、元数据(包含docker构建和运行的信息和父层的层次信息)。<br>每一层都包括了一直指向父层的指针。如果一个层没有这个指针，说明它处于最底层。<br><span><div align="center"><br><img src="/2020/12/30/image-container-relationship/docker_image2.png"></div></span></p><p>镜像是一堆只读层的统一视角，这些只读层重叠在一起，除了最下面一层，其他层都会有一个指针指向下一层。统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统。在用户角度看，只存在一个文件系统。镜像每一层都是只读层。</p><p><span><div align="center"><br><img src="/2020/12/30/image-container-relationship/docker_image3.png"></div></span></p><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>docker容器是由docker镜像创建的运行实例，容器也是一堆层的统一视角，不过容器最上面那一层是可读写的。即<br>容器 = 镜像 + 可读写层</p><p><span><div align="center"><br><img src="/2020/12/30/image-container-relationship/docker_container1.png"></div></span></p><p>一个容器中的进程可以对文件进行创建、修改、删除，这些改变都作用于可读写层。</p><p><span><div align="center"><br><img src="/2020/12/30/image-container-relationship/docker_container2.png"></div></span></p><p>docker容器类似虚拟机，只不过相对于虚拟机，docker守护进程可以直接与主操作系统进行通信，为各个docker容器分配资源，并保证每个容器都可以相互隔离独立，由于docker容器无需臃肿的从操作系统，docker可以节省大量的磁盘空间和其他系统资源。<br>3. docker仓库<br>docker仓库就是用来存放镜像的位置，docker运作中使用的默认仓库是<a href="https://registry.hub.docker.com/">docker hub公共仓库</a>，当用户创建了自己的镜像之后可以用push命令将它上传到共有或私有的仓库。这样下一次再需要使用该镜像时直接使用pull从仓库拉下来就可以了。</p><p>本文部分内容借鉴于：浪仙(<a href="https://www.cnblogs.com/LangXian/">https://www.cnblogs.com/LangXian/</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将讲解在docker中镜像和容器概念以及两者间的关系。&lt;/p&gt;
&lt;h2 id=&quot;docker镜像&quot;&gt;&lt;a href=&quot;#docker镜像&quot; class=&quot;headerlink&quot; title=&quot;docker镜像&quot;&gt;&lt;/a&gt;docker镜像&lt;/h2&gt;&lt;p&gt;docker的镜像</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用基本操作</title>
    <link href="http://example.com/2020/12/30/docker-method/"/>
    <id>http://example.com/2020/12/30/docker-method/</id>
    <published>2020-12-30T08:35:07.000Z</published>
    <updated>2021-03-16T07:27:11.620Z</updated>
    
    <content type="html"><![CDATA[<p>本文会总结一些docker的基础用法。</p><h2 id="Docker-基础调用">Docker 基础调用</h2><h4 id="docker-search-根据关键词搜索镜像文件"><strong>docker search</strong> (根据关键词搜索镜像文件)</h4><blockquote><p>docker search ubuntu 　　　　　　　　#查看包含“ubuntu”的image的名称</p></blockquote><p><img src="/2020/12/30/docker-method/docker_search.png" alt="docker search ubuntu"></p><h4 id="docker-pull-下载镜像到本地"><strong>docker pull</strong>(下载镜像到本地)</h4><blockquote><p>docker pull ubuntu　　　　　　　　#下载ubuntu:latest至本地(默认会下载最新版本的镜像,也可以自由选择下载镜像的版本，如ubuntu:15.10)。</p></blockquote><p><img src="/2020/12/30/docker-method/docker_pull.png" alt="docker pull ubuntu"></p><h4 id="docker-images-查看本地jenkins所有镜像"><strong>docker images</strong>(查看本地jenkins所有镜像)</h4><blockquote><p>docker images　　　　　　　　#列出本地所有镜像及其信息(标签，镜像ID，创建时间，镜像大小)</p></blockquote><p><img src="/2020/12/30/docker-method/docker_images.png" alt="docker images"></p><h4 id="docker-rmi-删除镜像"><strong>docker rmi</strong>(删除镜像)</h4><blockquote><p>docker rmi ubuntu　　　　　　　　#删除本地ubuntu镜像</p></blockquote><p><img src="/2020/12/30/docker-method/docker_rmi.png" alt="docker rmi ubuntu"></p><h4 id="docker-run-运行并启动一个新的容器"><strong>docker run</strong>(运行并启动一个新的容器)</h4><blockquote><p>docker run -it ubuntu　　　　　　　　#运行并启动一个ubuntu(如检测到本地无所需镜像，将先下载后再创建启动容器)<br>部分常用参数如下</p><ul><li>-i: 以交互模式运行容器，通常与-t同时使用；</li><li>-t: 为容器重新分配一个伪输入终端，通常与-i同时使用；</li><li>-p: 指定端口映射，格式为主机端口:容器端口</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-P: 随机端口映射，容器内部端口随机映射到主机端口；</li><li>–name=‘docker_test’:为容器指定一个名称；</li><li>–volume,-v:绑定一个卷</li></ul></blockquote><h4 id="docker-stop-停止一个容器的运行"><strong>docker stop</strong>(停止一个容器的运行)</h4><blockquote><p>docker stop Container_ID　　　　　　　　#停止相关容器运行</p></blockquote><h4 id="docker-rm-删除一个或多个容器"><strong>docker rm</strong>(删除一个或多个容器)</h4><blockquote><p>docker rm Container_ID　　　　　　　　#删除相关容器</p></blockquote><h4 id="docker-ps-显示所有容器进程"><strong>docker ps</strong>(显示所有容器进程)</h4><p><img src="/2020/12/30/docker-method/docker_ps.png" alt="docker ps list"></p><h4 id="docker-logs-查看容器日志"><strong>docker logs</strong>(查看容器日志)</h4><pre><code>&gt;docker logs [OPTIONS] CONTAINER_ID    Options:        --details       显示更多信息     -f,--follow        跟踪实时日志        --since string  显示自某个timestamp之后的日志        --tail string   从日志末尾显示多少行日志，默认是all     -t,--timestamps    显示时间戳        --until string  显示自某个timestamp之前的日志</code></pre><hr><h4 id="docker-network-查看docker网络信息"><strong>docker network</strong>(查看docker网络信息)</h4><blockquote><p>docker network ls<br>docker提供给我们4种网络模式。当我们完成docker engine的安装以后，docker会在每个engine上生成三种网络，bridge，none和host。</p></blockquote><ul><li>无网络模式–none<br>所有加入这个网络模式的container，都不能进行网络通信。</li><li>宿主网络模式–host<br>这种网络模式将container与宿主机的网络相通。</li><li>自定义网络<br>自定义网络主要包括三种，bridge，overlay，MACVLAN。对于bridge，我们可以自定义，然后就可以实现在一台host上的多个container间的通信，网络模式如下：<br><img src="/2020/12/30/docker-method/docker_network_bridge.png" alt="docker network--bridge"><ul><li>Overlay<br>我们可以使用“原生态”的swarm来实现“服务发现”和“DNS解析”。</li></ul></li></ul><h2 id="Dockerfile">Dockerfile</h2><p>Dockerfile是一个用来构建镜像的文本文件,文本内容包含了一条条构建镜像所需的指令和说明。如果想要使用该镜像的话，还需要使用 <em>docker run</em> 命令来运行这个镜像从而生成容器。</p><h4 id="使用Dockerfile定制镜像">使用Dockerfile定制镜像</h4><p>FROM：定制的镜像都是基于FROM的镜像作为base镜像，后续的操作也都是基于这个base镜像<br>RUN：用于执行后面的命令行命令。</p><ul><li>注意：Dockerfile的每次指令每执行一次都会在docker上新建一层。所以在构建镜像时应尽量减少过多无意义的层。</li></ul><h4 id="开始构建镜像">开始构建镜像</h4><p>我们构建了一个Dockerfile文件，并在文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39;</span><br></pre></td></tr></table></figure><p>在Dockerfile文件的存放目录下，使用build执行构建动作。通过下述语句构建了一个nginx:v3的镜像，其中最后的.代表本次执行的上下文路径(docker在构建镜像时，有时想要使用到本机的文件，docker build命令得知路径后，会将路径下的所有内容打包)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2020/12/30/docker-method/Dockerfile_build.png" alt="Dockerfile build"><br>根据上文内容，我们可以看出已经成功构建了一个新的镜像。</p><h4 id="常用指令详解">常用指令详解</h4><h5 id="COPY">COPY</h5><blockquote><p>复制指令，从上下文目录中复制文件或目录到容器里指定路径。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt; &lt;目标路径&gt;</span><br><span class="line">COPY nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><h5 id="CMD">CMD</h5><blockquote><p>类似于RUN指令，用于运行程序。为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。如果Dockerfile中存在多个CMD指令，仅最后一个生效</p></blockquote><ul><li>CMD在docker run时运行</li><li>RUN是在docker build时运行<br>格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt;</span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]　　　# 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span><br></pre></td></tr></table></figure><h5 id="ENTRYPOINT">ENTRYPOINT</h5><blockquote><p>类似于CMD指令，但其不会被docker run的命令行参数指定的指令所覆盖<br>格式：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</span><br><span class="line">CMD [&quot;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf&quot;] # 变参 </span><br></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$docker run  nginx:test</span><br></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  nginx:test -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</span><br></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</span><br></pre></td></tr></table></figure><h5 id="ENV">ENV</h5><blockquote><p>设置环境变量<br>格式：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;&#x3D;&lt;value1&gt; &lt;key2&gt;&#x3D;&lt;value2&gt;...</span><br><span class="line">ENV PATH&#x3D;&#39;&#x2F;app&#x2F;pwp&#x2F;am-pwa&#x2F;bin:$&#123;PATH&#125;&#39;</span><br></pre></td></tr></table></figure><h5 id="VOLUME">VOLUME</h5><blockquote><p>定义匿名数据卷，斌面重要的数据因容器重启而丢失<br>格式：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure><h5 id="EXPOSE">EXPOSE</h5><blockquote><p>声明端口，帮助镜像使用者明确镜像服务的守护端口，以方便配置映射。如果在启动容器时使用的docker run -P，EXPOSE的端口将被随机映射。<br>格式：<br><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></blockquote><hr><h2 id="Docker-Compose">Docker Compose</h2><blockquote><p>Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，可以使用YML文件来配置和整合所有容器需要的服务，然后使用一条命令控制YML文件配置即可创建并启动所有需要的服务。<br>Compose使用的步骤如下：</p><ul><li>使用Dokcerfile定义容器所需的环境</li><li>使用docker-compose.yml文件定义构成容器所需的服务，保证所有服务在隔离环境中可以一起运行</li><li>执行docker-compose up命令启动并运行整个程序</li></ul></blockquote><h3 id="YML文件配置指令参考">YML文件配置指令参考</h3><h4 id="version">version</h4><p>指定本yml依从的compose哪个版本所制定</p><h4 id="build">build</h4><p>指定为构建镜像上下文路径：<br>例如，指定为从上下文路径./build/client/Dockerfile构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.4&quot;</span><br><span class="line">services:</span><br><span class="line">  vue-client:</span><br><span class="line">  build: .&#x2F;build&#x2F;client</span><br></pre></td></tr></table></figure><h4 id="command">command</h4><p>覆盖容器启动的默认命令。</p><h4 id="container-name">container_name</h4><p>指定自定义容器名称，若无自定义名称，则系统将自动生成默认名称。</p><h4 id="environment">environment</h4><p>添加环境变量。可以使用数组、字典、任何布尔值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">      MONGODB_URL: &quot;mongodb:&#x2F;&#x2F;mongo1:27017&quot;</span><br><span class="line">      MONGODB_DB_NAME: &quot;$&#123;MONGODB_DB_NAME&#125;&quot;</span><br><span class="line">      LM_LICENSE_FILE: &quot;$&#123;MEDA_LM_LICENSE_FILE&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="healthcheck">healthcheck</h4><p>用于检测docker服务是否健康运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure><h4 id="image">image</h4><p>指定容器运行的镜像。</p><h4 id="restart">restart</h4><ul><li>no: 默认的重启策略，任何情况下不会重启容器。</li><li>always: 容器总是重新启动。</li><li>on-failure: 在容器非正常退出时会重启容器。</li><li>unless-syopped: 在容器退出时重启容器，但不考虑在docker进程启动时就停止了的容器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure><h4 id="volumnes">volumnes</h4><p>volumns负责将主机的数据卷或文件挂载到容器里。具体来说，volumns由两种设置方式。</p><ul><li>绝对路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ghost:  </span><br><span class="line"></span><br><span class="line">  image: ghost</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line"></span><br><span class="line">    - .&#x2F;ghost&#x2F;config.js:&#x2F;var&#x2F;lib&#x2F;ghost&#x2F;config.js</span><br></pre></td></tr></table></figure><ul><li>卷标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line"> mysql:  </span><br><span class="line">  image: mysql</span><br><span class="line">  container_name: mysql</span><br><span class="line">  volumes:</span><br><span class="line">    - mysql:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line"> mysql:</span><br></pre></td></tr></table></figure><p>第一种方式路径直接挂载到本地，更加直观，但需要管理本地的路径。第二种方式使用卷标的方式，相对简介，但不知道数据存储在本地具体什么位置，需要使用类似 <em>docker volume ls</em> 的方式查看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文会总结一些docker的基础用法。&lt;/p&gt;
&lt;h2 id=&quot;Docker-基础调用&quot;&gt;Docker 基础调用&lt;/h2&gt;
&lt;h4 id=&quot;docker-search-根据关键词搜索镜像文件&quot;&gt;&lt;strong&gt;docker search&lt;/strong&gt; (根据关键词搜索镜</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Dockerfile" scheme="http://example.com/tags/Dockerfile/"/>
    
    <category term="Docker-compose" scheme="http://example.com/tags/Docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要Docker?</title>
    <link href="http://example.com/2020/12/17/docker-value/"/>
    <id>http://example.com/2020/12/17/docker-value/</id>
    <published>2020-12-17T06:30:14.000Z</published>
    <updated>2021-02-20T06:40:01.450Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇介绍为什么要用Docker的文章</p><p>最近在工作中由于老板布置的任务需求，需要使用到Docker，所以想细致的了解学习一下<strong>Docker</strong>，总结了一些基础内容，分享给大家。</p><h2 id="为什么需要Docker"><a href="#为什么需要Docker" class="headerlink" title="为什么需要Docker"></a>为什么需要Docker</h2><p>Docker<strong>官方介绍</strong>(中文版)：<a href="http://www.docker-cn.com/what-docker#/developers">http://www.docker-cn…</a></p><p><img src="https://pic3.zhimg.com/80/v2-714d489867d85c7949ffebd891693c0e_720w.jpg" alt="Docker图标" title="Image"></p><blockquote><p>Docker 是世界领先的软件容器平台。<br>开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。<br>运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。<br>企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能</p></blockquote><ul><li>环境(切换/配置)繁琐<br>一般我们写程序的，能接触到好几个<strong>环境</strong>：</li></ul><p>自己写代码的环境叫做开发环境。<br>给测试去跑的环境叫做测试环境。<br>测试完可以对外使用的叫做生产环境。<br>其实我们在学习编程中，很多时间都浪费在“环境”上：</p><ul><li>如果我现在重装了系统，我想要跑我的war/jar包，我得去安装一下JDK、Tomcat、MySQL等配置各种的环境变量才能跑起来。</li><li>开开心心地跟着博主给出的步骤去写Demo，但总是有Bug。(这里我将版本/依赖也归纳在环境的范畴里边)。</li><li>好不容易在测试环境下跑起来了，在生产环境就各种出错！</li><li>跟着教学视频做分布式/集群的项目，跑一堆的虚拟机，每个虚拟机都要安装对应的环境。</li></ul><p>所以就有个笑话《千万不要跟程序员说，你的代码有bug》：</p><ul><li>他的第一反应是你的环境有问题，第二就是你是傻逼不会用吧。</li><li>你要跟他这么说：“这个程序运行的怎么运行的跟预期不一样，是我操作有问题吗？”。</li><li>这货就会第一反应“我擦，这是不是出bug了？”</li></ul><ul><li>应用间需要隔离<br>比如我写了两个应用(网站)，这两个应用部署在同一台服务器上，那可能会出现什么问题？</li></ul><ul><li>如果一个应用出现了问题，导致CPU占100%。那另一个应用也会受到关联，跟着一起凉凉了。</li><li>这两个应用是完全不同技术栈的应用，比如一个PHP，一个.NET。这两个应用各种的依赖软件都安装在同一个服务器上，可能就会造成各种冲突/无法兼容，这可能调试就非常麻烦了。</li></ul><h3 id="解决环境-切换-配置"><a href="#解决环境-切换-配置" class="headerlink" title="解决环境(切换/配置)"></a>解决环境(切换/配置)</h3><p>不知道大家有没有装过系统，比如说装Linux虚拟机，重装Windows系统，都是需要镜像的。</p><p>有了这个镜像，我们就可以<strong>运行</strong>这个镜像，来进行安装系统的操作(此处省略N个下一步)，于是我们的系统就装好了。一般来说，我们去官方渠道下载的镜像，都是<strong>纯净</strong>的。比如去官方下载Windows镜像，装完后之后桌面只有一个回收站。</p><p>但有过了解装系统的同学可能就会知道，有的镜像装完可能还有360这些软件，但系统的的确确是变了。简单来说，就是这些镜像添加了其他的东西(比如360软件、腾讯、千千静听等等软件)。</p><p>Docker也是这种思路，可以将我们的想要的环境<strong>构建</strong>(打包)成一个镜像，然后我们可以<strong>推送</strong>(发布)到网上去。想要用这个环 境的时候，在网上拉取一份就好了。</p><p>有了Docker，我们在搭环境的时候，跟以前的方式就不一样了。</p><ul><li><strong>之前</strong>：在开发环境构建出了一个war包，想跑到Linux下运行。我们得先在Linux下载好Java、Tomcat、MySQL，配置好对应的环境变量，将war包丢到Tomcat的webapps文件夹下，才能跑起来。</li><li><strong>现在</strong>：在Linux下直接拉取一份镜像(各种环境都配好了)，将镜像运行起来，把war包丢进去就好了。</li></ul><h3 id="解决应用之间隔离"><a href="#解决应用之间隔离" class="headerlink" title="解决应用之间隔离"></a>解决应用之间隔离</h3><p>说到这里，就得提出一个大家可能不认识的概念：LXC(Linux Containers)—&gt;Linux容器。</p>]]></content>
    
    
    <summary type="html">describe why we need to use Docker</summary>
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
</feed>
